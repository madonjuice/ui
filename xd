local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local username = LocalPlayer.Name

local function disableIfScript(obj)
    if obj and obj:IsA("LuaSourceContainer") then
        obj.Disabled = true
    end
end

local paths = {
    function() return LocalPlayer.PlayerGui:FindFirstChild("Start") and LocalPlayer.PlayerGui.Start:FindFirstChild("CheckPlayerW") end,
    function() return game:GetService("StarterGui"):FindFirstChild("Start") and game:GetService("StarterGui").Start:FindFirstChild("CheckPlayerW") end,
    function() return game:GetService("StarterPlayer").StarterCharacterScripts:FindFirstChild(" ") end,
    function() return workspace:FindFirstChild(username) and workspace[username]:FindFirstChild(" ") end
}

task.spawn(function()
    while task.wait(0.5) do 
        for _, getPath in ipairs(paths) do
            local obj = getPath()
            disableIfScript(obj)
        end
    end
end)

local loadingGui = Instance.new("ScreenGui")
loadingGui.Name = "FullscreenLoading"
loadingGui.Parent = game:GetService("CoreGui")
loadingGui.IgnoreGuiInset = true
loadingGui.ResetOnSpawn = false
loadingGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local background = Instance.new("Frame")
background.BackgroundColor3 = Color3.new(0, 0, 0)
background.Size = UDim2.new(1, 0, 1, 0)
background.Position = UDim2.new(0, 0, 0, 0)
background.BorderSizePixel = 0
background.Parent = loadingGui

local textLabel = Instance.new("TextLabel")
textLabel.Text = "Bypassing Anti-Cheat.."
textLabel.Font = Enum.Font.GothamBold
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextScaled = true
textLabel.Size = UDim2.new(1, 0, 0, 50)
textLabel.Position = UDim2.new(0, 0, 0.5, -25)
textLabel.BackgroundTransparency = 1
textLabel.Parent = background

task.wait(2)
textLabel.Text = "Successfully Bypassed Anti-Cheat.."
task.wait(1.5)
loadingGui:Destroy()

local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local LocalizationService = game:GetService("LocalizationService")
local Player = Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local isMobile = UIS.TouchEnabled and not UIS.KeyboardEnabled and not UIS.MouseEnabled

local function log(message)
    createNotification(message, 60, "failure")
end

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    LocalPlayer = Players.LocalPlayer
end

local PlayerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
if not PlayerGui then log("PlayerGui not found"); return end
local Start = PlayerGui:WaitForChild("Start", 10)
if not Start then log("Start not found"); return end
local CheckPlayerW = Start:WaitForChild("CheckPlayerW", 10)
if not CheckPlayerW then log("CheckPlayerW not found"); return end

local antiCheatBypassSuccess = false

if CheckPlayerW and CheckPlayerW:IsA("LocalScript") then
    CheckPlayerW.Disabled = true
    antiCheatBypassSuccess = true
    pcall(function()
        if type(getsenv) == "function" then
            local ok, fenv = pcall(function() return getsenv(CheckPlayerW) end)
            if ok and fenv then
                pcall(function()
                    if fenv.task and type(fenv.task.wait) == "function" then
                        fenv.task.wait = function() return end
                    end
                    fenv.pcall = function() return true end
                end)
            end
        end
    end)
else
    antiCheatBypassSuccess = false
end

local plr = game.Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")

local Starter = game.StarterPlayer.StarterCharacterScripts
local scripts = Starter:GetDescendants()
for _, script in pairs(scripts) do
    if script:IsA("LocalScript") then
        script.Disabled = true
        antiCheatBypassSuccess = antiCheatBypassSuccess and true
    end
end

local function createNotification(message, offsetY, status)
    local notificationGui = Instance.new("ScreenGui")
    notificationGui.Name = "NotificationGui"
    notificationGui.Parent = CoreGui
    notificationGui.ResetOnSpawn = false
    notificationGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local notificationFrame = Instance.new("Frame")
    notificationFrame.Size = UDim2.new(0, 220, 0, 60)
    notificationFrame.Position = UDim2.new(1, -230, 1, -70 - offsetY)
    notificationFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    notificationFrame.BackgroundTransparency = 0.3
    notificationFrame.BorderSizePixel = 0
    notificationFrame.Parent = notificationGui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = notificationFrame

    local stroke = Instance.new("UIStroke")
    stroke.Color = status == "success" and Color3.fromRGB(50, 255, 50) or Color3.fromRGB(255, 50, 50)
    stroke.Thickness = 1
    stroke.Transparency = 0.5
    stroke.Parent = notificationFrame

    local notificationLabel = Instance.new("TextLabel")
    notificationLabel.Size = UDim2.new(1, -20, 1, -10)
    notificationLabel.Position = UDim2.new(0, 10, 0, 5)
    notificationLabel.BackgroundTransparency = 1
    notificationLabel.Text = message
    notificationLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    notificationLabel.TextSize = 14
    notificationLabel.Font = Enum.Font.Gotham
    notificationLabel.TextXAlignment = Enum.TextXAlignment.Left
    notificationLabel.TextYAlignment = Enum.TextYAlignment.Center
    notificationLabel.TextWrapped = true
    notificationLabel.Parent = notificationFrame

    task.spawn(function()
        task.wait(8)
        for i = 0, 1, 0.05 do
            notificationFrame.BackgroundTransparency = 0.3 + (0.7 * i)
            stroke.Transparency = 0.5 + (0.5 * i)
            notificationLabel.TextTransparency = i
            task.wait(0.05)
        end
        notificationGui:Destroy()
    end)
end

createNotification(antiCheatBypassSuccess and "Anti-Cheat Bypassed" or "Anti-Cheat Bypass Failed", 0, antiCheatBypassSuccess and "success" or "failure")

local function getExecutor()
    if syn then return "Synapse X"
    elseif Krnl then return "Krnl"
    elseif Fluxus then return "Fluxus"
    elseif getexecutorname then return getexecutorname()
    else return "Unknown" end
end

local executor = getExecutor():lower()
local unsupportedExecutors = {"cloudy", "xeno", "solara", "zorara", "jjsploit"}
for _, ex in pairs(unsupportedExecutors) do
    if executor:find(ex) then
        local KickGui = Instance.new("ScreenGui")
        KickGui.Name = "KickMessage"
        KickGui.Parent = CoreGui
        KickGui.ResetOnSpawn = false

        local KickFrame = Instance.new("Frame")
        KickFrame.Size = UDim2.new(0, 300, 0, 100)
        KickFrame.Position = UDim2.new(0.5, -150, 0.5, -50)
        KickFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        KickFrame.Parent = KickGui

        local KickLabel = Instance.new("TextLabel")
        KickLabel.Size = UDim2.new(1, 0, 1, 0)
        KickLabel.BackgroundTransparency = 1
        KickLabel.Text = "EXECUTOR NOT SUPPORTED"
        KickLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        KickLabel.TextSize = 18
        KickLabel.Font = Enum.Font.GothamBold
        KickLabel.TextXAlignment = Enum.TextXAlignment.Center
        KickLabel.TextYAlignment = Enum.TextYAlignment.Center
        KickLabel.Parent = KickFrame

        task.wait(2)
        plr:Kick("Executor not supported: " .. executor)
        return
    end
end

local function getHWID()
    local hwid = "N/A"
    pcall(function()
        hwid = game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    return hwid
end

task.spawn(function()
    local request = http_request or request or (syn and syn.request)
    pcall(function()
        request({
            Method = "POST",
            Url = "https://webhook-protect-2.vercel.app/api/webhook?id=Z3k4MXNDNTl5N0lFVm5oUmZxdThJQTpLVVI2Q1JkMWdrRWtuUnBIUl9SV2JQX0x3OGVfSWtWeTRSS1V0ZWV0aGFmdG45NUhHZjZwQXRXY1pJeVV6TXBXLTFadVVmeTFZWTQ3OGp6d0UxRHQycUt1dTlSbEZXTDRYRnMwMHVoZ3VHQ3FjMVM1UnV1MjBmLVpNMUpiUGk0UVcyVjdJUkFVUlpSQU5OeVVLTE9NYjBGUk1BT1hkOHNjVHNsNWFTeWp0dW8",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({
                username = "kyro",
                embeds = {{
                    title = MarketplaceService:GetProductInfo(game.PlaceId).Name,
                    description = "**" .. Players.LocalPlayer.Name .. "** has executed the script!",
                    color = 0,
                    fields = {
                        {name = "Username", value = Players.LocalPlayer.Name, inline = true},
                        {name = "Display Name", value = Players.LocalPlayer.DisplayName, inline = true},
                        {name = "Executor", value = getExecutor(), inline = true},
                        {name = "Place ID", value = tostring(game.PlaceId)},
                        {name = "Account Age", value = Players.LocalPlayer.AccountAge .. " days old"},
                        {name = "Hwid", value = getHWID()},
                        {name = "Country", value = LocalizationService:GetCountryRegionForPlayerAsync(Players.LocalPlayer)},
                        {name = "Players in Server", value = tostring(#Players:GetPlayers())}
                    }
                }}
            })
        })
    end)
end)

local success, gameInfo = pcall(function()
    return MarketplaceService:GetProductInfo(game.PlaceId)
end)
if not success or not gameInfo or not gameInfo.Name:find("TPS") then
    log("Error: Script not compatible with this game.")
    return
end

local legreach = false
local LegdistanceThreshold = 2
local ballCollision = false
local leftLeg, rightLeg, ball, hitboxPart
local RunSteppedMobile
local DistanceReachMobile = 2
local existingMarker = nil
local allReachEnabled = false
local showHitbox = false
local XReachThreshold = 2
local YReachThreshold = 2
local ZReachThreshold = 2

local function createHitbox(character)
    if not showHitbox or not allReachEnabled then return end
    if hitboxPart then
        hitboxPart:Destroy()
    end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        log("Error: HumanoidRootPart not found.")
        return
    end

    hitboxPart = Instance.new("Part")
    hitboxPart.Name = "ReachHitbox"
    hitboxPart.Size = Vector3.new(XReachThreshold * 2, YReachThreshold * 2, ZReachThreshold * 2)
    hitboxPart.Position = rootPart.Position
    hitboxPart.Anchored = true
    hitboxPart.Transparency = 0.7
    hitboxPart.Color = Color3.fromRGB(0, 140, 255)
    hitboxPart.CanCollide = false
    hitboxPart.Parent = workspace

    local boxHandle = Instance.new("BoxHandleAdornment")
    boxHandle.Size = hitboxPart.Size
    boxHandle.Adornee = hitboxPart
    boxHandle.Transparency = 0.5
    boxHandle.Color3 = Color3.fromRGB(0, 140, 255)
    boxHandle.AlwaysOnTop = true
    boxHandle.ZIndex = 5
    boxHandle.Parent = hitboxPart

    RunService.RenderStepped:Connect(function()
        if hitboxPart and rootPart and allReachEnabled and showHitbox then
            hitboxPart.Position = rootPart.Position
        elseif hitboxPart then
            hitboxPart:Destroy()
            hitboxPart = nil
        end
    end)
end

local function setupCharacter()
    local char = Player.Character
    if not char then
        char = Player.CharacterAdded:Wait()
    end

    local maxAttempts = 10
    local attempts = 0
    local humanoid
    while attempts < maxAttempts do
        humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            if humanoid.RigType == Enum.HumanoidRigType.R6 then
                leftLeg = char:FindFirstChild("Left Leg")
                rightLeg = char:FindFirstChild("Right Leg")
            else
                leftLeg = char:FindFirstChild("LeftFoot") or char:FindFirstChild("LeftLowerLeg")
                rightLeg = char:FindFirstChild("RightFoot") or char:FindFirstChild("RightLowerLeg")
            end
            ball = workspace:FindFirstChild("TPSSystem") and workspace.TPSSystem:FindFirstChild("TPS")
            if leftLeg and rightLeg and ball and humanoid then
                break
            end
        end
        attempts = attempts + 1
        task.wait(0.5)
    end

    if not (leftLeg and rightLeg and ball and humanoid) then
        log("Error: Failed to find all required character parts or ball.")
        return false
    end

    if ballCollision then
        local constraints = {
            ball:FindFirstChild("NoCollisionConstraintA"),
            ball:FindFirstChild("NoCollisionConstraintB"),
            ball:FindFirstChild("NoCollisionConstraintC")
        }
        for _, constraint in pairs(constraints) do
            if constraint and constraint:IsA("NoCollisionConstraint") then
                constraint.Enabled = true
            end
        end
    else
        local constraints = {
            ball:FindFirstChild("NoCollisionConstraintA"),
            ball:FindFirstChild("NoCollisionConstraintB"),
            ball:FindFirstChild("NoCollisionConstraintC")
        }
        for _, constraint in pairs(constraints) do
            if constraint and constraint:IsA("NoCollisionConstraint") then
                constraint.Enabled = false
            end
        end
    end

    if humanoid then
        humanoid.AutoJumpEnabled = true
        task.spawn(function()
            local elapsed = 0
            while elapsed < 5 do
                if humanoid then
                    humanoid.AutoJumpEnabled = true
                end
                task.wait(0.1)
                elapsed = elapsed + 0.1
            end
        end)
    end

    if allReachEnabled and showHitbox then
        createHitbox(char)
    end
    return true
end

task.spawn(setupCharacter)

Player.CharacterAdded:Connect(function(newChar)
    leftLeg, rightLeg, ball, hitboxPart = nil, nil, nil, nil
    local success = task.spawn(setupCharacter)
    if legreach and success then
        task.spawn(checkLegs)
    end
    if allReachEnabled and success then
        task.spawn(checkAdvancedReach)
    end
end)

local function checkLegs()
    while legreach do
        if not (leftLeg and rightLeg and ball) then
            local success = setupCharacter()
            if not success then
                task.wait(1)
                continue
            end
        end

        task.wait()
        if leftLeg and ball and (ball.Position - leftLeg.Position).Magnitude <= LegdistanceThreshold then
            firetouchinterest(leftLeg, ball, 0)
            firetouchinterest(leftLeg, ball, 1)
        end
        if rightLeg and ball and (ball.Position - rightLeg.Position).Magnitude <= LegdistanceThreshold then
            firetouchinterest(rightLeg, ball, 0)
            firetouchinterest(rightLeg, ball, 1)
        end
    end
end

local function checkAdvancedReach()
    while allReachEnabled do
        if not (leftLeg and rightLeg and ball) then
            local success = setupCharacter()
            if not success then
                task.wait(1)
                continue
            end
        end

        task.wait()
        local rootPart = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then continue end

        local humanoid = Player.Character:FindFirstChild("Humanoid")
        if not humanoid then continue end

        local partsToCheck = {}
        if humanoid.RigType == Enum.HumanoidRigType.R6 then
            partsToCheck = {
                {part = leftLeg, name = "Left Leg"},
                {part = rightLeg, name = "Right Leg"}
            }
        else
            partsToCheck = {
                {part = leftLeg, name = "LeftFoot/LowerLeg"},
                {part = rightLeg, name = "RightFoot/LowerLeg"}
            }
        end

        for _, partInfo in ipairs(partsToCheck) do
            if partInfo.part and ball then
                local delta = ball.Position - partInfo.part.Position
                local shouldFire = math.abs(delta.X) <= XReachThreshold and 
                                  math.abs(delta.Y) <= YReachThreshold and 
                                  math.abs(delta.Z) <= ZReachThreshold
                if shouldFire then
                    firetouchinterest(partInfo.part, ball, 0)
                    firetouchinterest(partInfo.part, ball, 1)
                end
            end
        end
    end
end

if not CoreGui then
    log("Error: CoreGui not accessible.")
    return
end
local KyroGui = Instance.new("ScreenGui")
KyroGui.Name = "KyroGui"
KyroGui.Parent = CoreGui
KyroGui.ResetOnSpawn = false
KyroGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
KyroGui.IgnoreGuiInset = true
if not KyroGui then
    log("Error: Failed to create KyroGui.")
    return
end

local baseSize = UDim2.new(0, 600, 0, 450)
local mobileSize = UDim2.new(0, 300, 0, 225)
local uiSize = isMobile and mobileSize or baseSize

local MainFrame = Instance.new("Frame")
MainFrame.Size = uiSize
MainFrame.Position = UDim2.new(0.5, -uiSize.X.Offset / 2, 0.5, -uiSize.Y.Offset / 2)
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MainFrame.BackgroundTransparency = 0.3
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Parent = KyroGui

local MainCorner = Instance.new("UICorner")
MainCorner.CornerRadius = UDim.new(0, 8)
MainCorner.Parent = MainFrame

local MainStroke = Instance.new("UIStroke")
MainStroke.Color = Color3.fromRGB(0, 140, 255)
MainStroke.Thickness = 1
MainStroke.Transparency = 0.5
MainStroke.Parent = MainFrame

local TitleFrame = Instance.new("Frame")
TitleFrame.Size = UDim2.new(1, 0, 0, uiSize.Y.Offset * 40 / 450)
TitleFrame.BackgroundTransparency = 1
TitleFrame.Parent = MainFrame

local MainTitle = Instance.new("TextLabel")
MainTitle.Size = UDim2.new(1, -80, 0, uiSize.Y.Offset * 30 / 450)
MainTitle.Position = UDim2.new(0, 40, 0, 5)
MainTitle.BackgroundTransparency = 1
MainTitle.Text = "97 is king heh mobile version"
MainTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
MainTitle.TextSize = isMobile and 14 or 20
MainTitle.Font = Enum.Font.GothamBold
MainTitle.TextXAlignment = Enum.TextXAlignment.Center
MainTitle.Parent = TitleFrame

local dragging = false
local dragStartPos = nil
local startPos = nil

TitleFrame.InputBegan:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
        dragging = true
        dragStartPos = input.Position
        startPos = MainFrame.Position
    end
end)

TitleFrame.InputEnded:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
        dragging = false
    end
end)

UIS.InputChanged:Connect(function(input)
    if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStartPos
        MainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, uiSize.Y.Offset * 30 / 450, 0, uiSize.Y.Offset * 30 / 450)
CloseButton.Position = UDim2.new(1, -40, 0, 5)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(200, 200, 200)
CloseButton.TextSize = isMobile and 12 or 16
CloseButton.Font = Enum.Font.Gotham
CloseButton.Parent = TitleFrame

CloseButton.MouseButton1Click:Connect(function()
    KyroGui:Destroy()
end)

CloseButton.MouseEnter:Connect(function()
    CloseButton.TextColor3 = Color3.fromRGB(0, 140, 255)
end)

CloseButton.MouseLeave:Connect(function()
    CloseButton.TextColor3 = Color3.fromRGB(200, 200, 200)
end)

local MinimizeButton = Instance.new("TextButton")
MinimizeButton.Size = UDim2.new(0, uiSize.Y.Offset * 30 / 450, 0, uiSize.Y.Offset * 30 / 450)
MinimizeButton.Position = UDim2.new(1, -80, 0, 5)
MinimizeButton.BackgroundTransparency = 1
MinimizeButton.Text = "âˆ’"
MinimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
MinimizeButton.TextSize = isMobile and 12 or 16
MinimizeButton.Font = Enum.Font.Gotham
MinimizeButton.Parent = TitleFrame

local isMinimized = false
local minimizeCircle = nil
local circleDragging = false
local dragStartPos = nil
local circleStartPos = nil
local movementThreshold = 5

MinimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        MainFrame.Visible = false
        if not minimizeCircle and KyroGui then
            minimizeCircle = Instance.new("Frame")
            minimizeCircle.Size = UDim2.new(0, uiSize.Y.Offset * 62.5 / 450, 0, uiSize.Y.Offset * 62.5 / 450)
            minimizeCircle.Position = UDim2.new(0.5, -(uiSize.Y.Offset * 62.5 / 450) / 2, 0.5, -(uiSize.Y.Offset * 62.5 / 450) / 2)
            minimizeCircle.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
            minimizeCircle.BackgroundTransparency = 0.3
            minimizeCircle.ZIndex = 10
            minimizeCircle.Parent = KyroGui

            local circleCorner = Instance.new("UICorner")
            circleCorner.CornerRadius = UDim.new(0.5, 0)
            circleCorner.Parent = minimizeCircle

            local circleStroke = Instance.new("UIStroke")
            circleStroke.Color = Color3.fromRGB(0, 140, 255)
            circleStroke.Thickness = 1
            circleStroke.Transparency = 0.5
            circleStroke.Parent = minimizeCircle

            local imageLabel = Instance.new("ImageLabel")
            imageLabel.Size = UDim2.new(0.8, 0, 0.8, 0)
            imageLabel.Position = UDim2.new(0.1, 0, 0.1, 0)
            imageLabel.BackgroundTransparency = 1
            imageLabel.Image = "rbxassetid://134262569335890"
            imageLabel.Parent = minimizeCircle

            local circleButton = Instance.new("TextButton")
            circleButton.Size = UDim2.new(1, 0, 1, 0)
            circleButton.BackgroundTransparency = 1
            circleButton.Text = ""
            circleButton.Parent = minimizeCircle

            circleButton.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if not minimizeCircle then return end
                    circleDragging = false
                    dragStartPos = input.Position
                    circleStartPos = minimizeCircle.Position
                end
            end)

            circleButton.InputChanged:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                    if dragStartPos and minimizeCircle then
                        local delta = input.Position - dragStartPos
                        if delta.Magnitude > movementThreshold then
                            circleDragging = true
                            minimizeCircle.Position = UDim2.new(
                                circleStartPos.X.Scale,
                                circleStartPos.X.Offset + delta.X,
                                circleStartPos.Y.Scale,
                                circleStartPos.Y.Offset + delta.Y
                            )
                        end
                    end
                end
            end)

            circleButton.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    if not minimizeCircle then return end
                    if not circleDragging then
                        isMinimized = false
                        MainFrame.Visible = true
                        minimizeCircle:Destroy()
                        minimizeCircle = nil
                    end
                    circleDragging = false
                    dragStartPos = nil
                    circleStartPos = nil
                end
            end)
        end
    else
        MainFrame.Visible = true
        if minimizeCircle then
            minimizeCircle:Destroy()
            minimizeCircle = nil
        end
    end
end)

MinimizeButton.MouseEnter:Connect(function()
    MinimizeButton.TextColor3 = Color3.fromRGB(0, 140, 255)
end)

MinimizeButton.MouseLeave:Connect(function()
    MinimizeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
end)

local Sidebar = Instance.new("Frame")
Sidebar.Size = UDim2.new(0, uiSize.X.Offset * 100 / 600, 1, -uiSize.Y.Offset * 40 / 450)
Sidebar.Position = UDim2.new(0, 0, 0, uiSize.Y.Offset * 40 / 450)
Sidebar.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
Sidebar.BackgroundTransparency = 0.3
Sidebar.BorderSizePixel = 0
Sidebar.ClipsDescendants = true
Sidebar.Parent = MainFrame

local ContentFrame = Instance.new("Frame")
ContentFrame.Size = UDim2.new(0, uiSize.X.Offset * 500 / 600, 1, -uiSize.Y.Offset * 40 / 450)
ContentFrame.Position = UDim2.new(0, uiSize.X.Offset * 100 / 600, 0, uiSize.Y.Offset * 40 / 450)
ContentFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ContentFrame.BackgroundTransparency = 0.3
ContentFrame.BorderSizePixel = 0
ContentFrame.Parent = MainFrame

local currentTab = nil
local tabs = {}

local function updateCanvasSize(scrollingFrame)
    local layout = scrollingFrame:FindFirstChildOfClass("UIListLayout")
    if layout then
        local totalHeight = layout.AbsoluteContentSize.Y
        scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight + (isMobile and 60 or 120))
    end
end

local function createTab(name, callback)
    if name == nil then
        name = "Unnamed Tab"
    end

    local tabHeight = uiSize.Y.Offset * 40 / 450
    local tabIndex = #tabs
    local TabButton = Instance.new("TextButton")
    TabButton.Size = UDim2.new(1, 0, 0, tabHeight)
    TabButton.Position = UDim2.new(0, 0, 0, 10 + (tabIndex * (tabHeight + (isMobile and 5 or 10))))
    TabButton.BackgroundTransparency = 1
    TabButton.Text = ""
    TabButton.Parent = Sidebar

    local LabelFrame = Instance.new("Frame")
    LabelFrame.Size = UDim2.new(1, 0, 1, 0)
    LabelFrame.BackgroundTransparency = 1
    LabelFrame.Parent = TabButton

    local IndicatorLabel = Instance.new("TextLabel")
    IndicatorLabel.Size = UDim2.new(0, uiSize.X.Offset * 10 / 600, 1, 0)
    IndicatorLabel.Position = UDim2.new(0, uiSize.X.Offset * 20 / 600, 0, 0)
    IndicatorLabel.BackgroundTransparency = 1
    IndicatorLabel.Text = "|"
    IndicatorLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    IndicatorLabel.TextSize = isMobile and 10 or 14
    IndicatorLabel.Font = Enum.Font.Gotham
    IndicatorLabel.TextXAlignment = Enum.TextXAlignment.Left
    IndicatorLabel.Parent = LabelFrame

    local NameLabel = Instance.new("TextLabel")
    NameLabel.Size = UDim2.new(1, -uiSize.X.Offset * 30 / 600, 1, 0)
    NameLabel.Position = UDim2.new(0, uiSize.X.Offset * 30 / 600, 0, 0)
    NameLabel.BackgroundTransparency = 1
    NameLabel.Text = name
    NameLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    NameLabel.TextSize = isMobile and 10 or 14
    NameLabel.Font = Enum.Font.Gotham
    NameLabel.TextXAlignment = Enum.TextXAlignment.Left
    NameLabel.Parent = LabelFrame

    local TabContent = Instance.new("Frame")
    TabContent.Size = UDim2.new(1, 0, 1, 0)
    TabContent.BackgroundTransparency = 1
    TabContent.Visible = false
    TabContent.Parent = ContentFrame

    local ScrollingFrame = Instance.new("ScrollingFrame")
    ScrollingFrame.Size = UDim2.new(1, -uiSize.X.Offset * 20 / 600, 1, -uiSize.Y.Offset * 20 / 450)
    ScrollingFrame.Position = UDim2.new(0, uiSize.X.Offset * 10 / 600, 0, uiSize.Y.Offset * 10 / 450)
    ScrollingFrame.BackgroundTransparency = 1
    ScrollingFrame.ScrollBarThickness = isMobile and 2 or 4
    ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    ScrollingFrame.Parent = TabContent

    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, isMobile and 10 or 20)
    UIListLayout.Parent = ScrollingFrame

    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        updateCanvasSize(ScrollingFrame)
    end)

    if TabButton then
        TabButton.MouseButton1Click:Connect(function()
            if currentTab then
                currentTab.Visible = false
            end
            TabContent.Visible = true
            currentTab = TabContent
            for _, tab in pairs(tabs) do
                tab.indicatorLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                tab.nameLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
            IndicatorLabel.TextColor3 = Color3.fromRGB(0, 140, 255)
            NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            updateCanvasSize(ScrollingFrame)
        end)
    else
        log("Error: TabButton is nil during creation.")
    end

    table.insert(tabs, {
        button = TabButton,
        content = TabContent,
        indicatorLabel = IndicatorLabel,
        nameLabel = NameLabel,
        originalName = name
    })
    callback(ScrollingFrame)
end

local function createSection(parent, title, customPaddingTop)
    local SectionFrame = Instance.new("Frame")
    SectionFrame.Size = UDim2.new(1, 0, 0, 0)
    SectionFrame.BackgroundTransparency = 1
    SectionFrame.AutomaticSize = Enum.AutomaticSize.Y
    SectionFrame.Parent = parent

    local SectionTitle = Instance.new("TextLabel")
    SectionTitle.Size = UDim2.new(1, 0, 0, isMobile and 15 or 25)
    SectionTitle.BackgroundTransparency = 1
    SectionTitle.Text = title
    SectionTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    SectionTitle.TextSize = isMobile and 12 or 16
    SectionTitle.Font = Enum.Font.GothamBold
    SectionTitle.TextXAlignment = Enum.TextXAlignment.Left
    SectionTitle.Parent = SectionFrame

    local Content = Instance.new("Frame")
    Content.Size = UDim2.new(1, 0, 0, 0)
    Content.BackgroundTransparency = 1
    Content.AutomaticSize = Enum.AutomaticSize.Y
    Content.Parent = SectionFrame

    local UIListLayout = Instance.new("UIListLayout")
    UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayout.Padding = UDim.new(0, isMobile and 10 or 15)
    UIListLayout.Parent = Content

    local Padding = Instance.new("UIPadding")
    Padding.PaddingTop = customPaddingTop or UDim.new(0, isMobile and 10 or 15)
    Padding.PaddingBottom = UDim.new(0, isMobile and 10 or 15)
    Padding.Parent = Content

    UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        updateCanvasSize(parent)
    end)

    return Content, SectionTitle
end

local function createToggle(parent, text, callback)
    local ToggleFrame = Instance.new("Frame")
    ToggleFrame.Size = UDim2.new(1, 0, 0, isMobile and 30 or 40)
    ToggleFrame.BackgroundTransparency = 1
    ToggleFrame.Parent = parent

    local ToggleLabel = Instance.new("TextLabel")
    ToggleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    ToggleLabel.BackgroundTransparency = 1
    ToggleLabel.Text = text
    ToggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleLabel.TextSize = isMobile and 10 or 14
    ToggleLabel.Font = Enum.Font.Gotham
    ToggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    ToggleLabel.TextYAlignment = Enum.TextYAlignment.Center
    ToggleLabel.Parent = ToggleFrame

    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Size = UDim2.new(0, isMobile and 30 or 40, 0, isMobile and 12 or 16)
    ToggleButton.Position = UDim2.new(0.85, 0, 0.5, isMobile and -6 or -8)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    ToggleButton.Text = ""
    ToggleButton.Parent = ToggleFrame

    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(0, isMobile and 3 or 4)
    ToggleCorner.Parent = ToggleButton

    local ToggleStroke = Instance.new("UIStroke")
    ToggleStroke.Color = Color3.fromRGB(255, 255, 255)
    ToggleStroke.Thickness = 1
    ToggleStroke.Transparency = 0.5
    ToggleStroke.Parent = ToggleButton

    local ToggleStateLabel = Instance.new("TextLabel")
    ToggleStateLabel.Size = UDim2.new(1, 0, 1, 0)
    ToggleStateLabel.BackgroundTransparency = 1
    ToggleStateLabel.Text = "Off"
    ToggleStateLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleStateLabel.TextSize = isMobile and 8 or 10
    ToggleStateLabel.Font = Enum.Font.Gotham
    ToggleStateLabel.TextXAlignment = Enum.TextXAlignment.Center
    ToggleStateLabel.TextYAlignment = Enum.TextYAlignment.Center
    ToggleStateLabel.Parent = ToggleButton

    local state = false
    ToggleButton.MouseButton1Click:Connect(function()
        state = not state
        ToggleButton.BackgroundColor3 = state and Color3.fromRGB(0, 140, 255) or Color3.fromRGB(30, 30, 30)
        ToggleStateLabel.Text = state and "On" or "Off"
        callback(state)
    end)

    updateCanvasSize(parent.Parent.Parent)
    return ToggleButton, ToggleStateLabel
end

local function createSlider(parent, text, min, max, value, callback)
    local SliderFrame = Instance.new("Frame")
    SliderFrame.Size = UDim2.new(1, 0, 0, isMobile and 40 or 60)
    SliderFrame.BackgroundTransparency = 1
    SliderFrame.Parent = parent

    local SliderLabel = Instance.new("TextLabel")
    SliderLabel.Size = UDim2.new(1, 0, 0, isMobile and 15 or 25)
    SliderLabel.BackgroundTransparency = 1
    SliderLabel.Text = text .. ": " .. string.format("%.1f", value)
    SliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    SliderLabel.TextSize = isMobile and 10 or 14
    SliderLabel.Font = Enum.Font.Gotham
    SliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    SliderLabel.Parent = SliderFrame

    local SliderBar = Instance.new("Frame")
    SliderBar.Size = UDim2.new(1, 0, 0, isMobile and 3 or 6)
    SliderBar.Position = UDim2.new(0, 0, 0, isMobile and 25 or 35)
    SliderBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    SliderBar.Parent = SliderFrame

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, isMobile and 1 or 3)
    Corner.Parent = SliderBar

    local SliderFill = Instance.new("Frame")
    SliderFill.Size = UDim2.new((value - min) / (max - min), 0, 1, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
    SliderFill.Parent = SliderBar

    local CornerFill = Instance.new("UICorner")
    CornerFill.CornerRadius = UDim.new(0, isMobile and 1 or 3)
    CornerFill.Parent = SliderFill

    local SliderHandle = Instance.new("Frame")
    SliderHandle.Size = UDim2.new(0, isMobile and 8 or 16, 0, isMobile and 8 or 16)
    SliderHandle.Position = UDim2.new((value - min) / (max - min), isMobile and -4 or -8, 0, isMobile and -3 or -5)
    SliderHandle.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
    SliderHandle.Parent = SliderBar

    local HandleCorner = Instance.new("UICorner")
    HandleCorner.CornerRadius = UDim.new(0, isMobile and 4 or 8)
    HandleCorner.Parent = SliderHandle

    local SliderButton = Instance.new("TextButton")
    SliderButton.Size = UDim2.new(1, 0, 1, 0)
    SliderButton.BackgroundTransparency = 1
    SliderButton.Text = ""
    SliderButton.Parent = SliderBar

    local dragging = false
    SliderButton.MouseButton1Down:Connect(function()
        dragging = true
    end)

    SliderButton.MouseButton1Up:Connect(function()
        dragging = false
    end)

    SliderButton.MouseLeave:Connect(function()
        dragging = false
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local mousePos = UIS:GetMouseLocation()
            local relPos = (mousePos.X - SliderBar.AbsolutePosition.X) / SliderBar.AbsoluteSize.X
            relPos = math.clamp(relPos, 0, 1)
            local newValue = min + (relPos * (max - min))
            newValue = math.round(newValue * 10) / 10
            SliderFill.Size = UDim2.new((newValue - min) / (max - min), 0, 1, 0)
            SliderHandle.Position = UDim2.new((newValue - min) / (max - min), isMobile and -4 or -8, 0, isMobile and -3 or -5)
            SliderLabel.Text = text .. ": " .. string.format("%.1f", newValue)
            callback(newValue)
        end
    end)

    updateCanvasSize(parent.Parent.Parent)
    return SliderBar, SliderFill, SliderHandle, SliderLabel
end

local function createButton(parent, text, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0.5, 0, 0, isMobile and 20 or 30)
    Button.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
    Button.Text = text
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = isMobile and 10 or 14
    Button.Font = Enum.Font.GothamBold
    Button.Parent = parent

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, isMobile and 3 or 4)
    Corner.Parent = Button

    Button.MouseEnter:Connect(function()
        Button.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
    end)
    Button.MouseLeave:Connect(function()
        Button.BackgroundColor3 = Color3.fromRGB(0, 140, 255)
    end)

    Button.MouseButton1Click:Connect(callback)

    updateCanvasSize(parent.Parent.Parent)
    return Button
end

local function createTextbox(parent, text, callback)
    local TextboxFrame = Instance.new("Frame")
    TextboxFrame.Size = UDim2.new(1, 0, 0, isMobile and 25 or 35)
    TextboxFrame.BackgroundTransparency = 1
    TextboxFrame.Parent = parent

    local TextboxLabel = Instance.new("TextLabel")
    TextboxLabel.Size = UDim2.new(0.5, 0, 1, 0)
    TextboxLabel.BackgroundTransparency = 1
    TextboxLabel.Text = text
    TextboxLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TextboxLabel.TextSize = isMobile and 10 or 14
    TextboxLabel.Font = Enum.Font.Gotham
    TextboxLabel.TextXAlignment = Enum.TextXAlignment.Left
    TextboxLabel.TextYAlignment = Enum.TextYAlignment.Center
    TextboxLabel.Parent = TextboxFrame

    local Textbox = Instance.new("TextBox")
    Textbox.Size = UDim2.new(0.3, 0, 0, isMobile and 15 or 20)
    Textbox.Position = UDim2.new(0.5, 0, 0.5, isMobile and -7 or -10)
    Textbox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    Textbox.Text = ""
    Textbox.TextColor3 = Color3.fromRGB(255, 255, 255)
    Textbox.TextSize = isMobile and 8 or 12
    Textbox.Font = Enum.Font.Gotham
    Textbox.Parent = TextboxFrame

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, isMobile and 3 or 4)
    Corner.Parent = Textbox

    local Stroke = Instance.new("UIStroke")
    Stroke.Color = Color3.fromRGB(255, 255, 255)
    Stroke.Thickness = 1
    Stroke.Transparency = 0.5
    Stroke.Parent = Textbox

    Textbox.FocusLost:Connect(function()
        callback(Textbox.Text)
    end)

    updateCanvasSize(parent.Parent.Parent)
end

local function createLabel(parent, text)
    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(1, 0, 0, isMobile and 15 or 25)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.TextSize = isMobile and 10 or 14
    Label.Font = Enum.Font.Gotham
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.TextYAlignment = Enum.TextYAlignment.Center
    Label.Parent = parent

    updateCanvasSize(parent.Parent.Parent)
end

local function getPing()
    local ping = "N/A"
    pcall(function()
        ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()) .. " ms"
    end)
    return ping
end

createTab("Home", function(content)
    local WelcomeSection, WelcomeTitle = createSection(content, "Welcome, " .. Player.DisplayName)
    WelcomeTitle.TextSize = isMobile and 8 or 10

    local AvatarFrame = Instance.new("ImageLabel")
    AvatarFrame.Size = UDim2.new(0, isMobile and 25 or 50, 0, isMobile and 25 or 50)
    AvatarFrame.Position = UDim2.new(0, isMobile and 5 or 10, 1, isMobile and -35 or -60)
    AvatarFrame.BackgroundTransparency = 1
    AvatarFrame.Image = Players:GetUserThumbnailAsync(Player.UserId, Enum.ThumbnailType.AvatarBust, Enum.ThumbnailSize.Size150x150)
    AvatarFrame.Parent = WelcomeSection

    local AvatarStroke = Instance.new("UIStroke")
    AvatarStroke.Color = Color3.fromRGB(0, 140, 255)
    AvatarStroke.Thickness = 1
    AvatarStroke.Transparency = 0.5
    AvatarStroke.Parent = AvatarFrame

    local AvatarCorner = Instance.new("UICorner")
    AvatarCorner.CornerRadius = UDim.new(0, isMobile and 2 or 4)
    AvatarCorner.Parent = AvatarFrame

    WelcomeTitle.Size = UDim2.new(1, 0, 0, isMobile and 10 or 15)
    WelcomeTitle.Position = UDim2.new(0, isMobile and 5 or 10, 1, isMobile and -50 or -80)

    local InfoSection = createSection(content, "User Information")
    createLabel(InfoSection, "Username: " .. Player.Name)
    createLabel(InfoSection, "Display Name: " .. Player.DisplayName)
    createLabel(InfoSection, "Access Method: Free")
    createLabel(InfoSection, "Executor: " .. getExecutor())

    local StatsSection = createSection(content, "Game Stats")
    createLabel(StatsSection, "Server Players: " .. #Players:GetPlayers())
    createLabel(StatsSection, "Ping: " .. getPing())
end)

createTab("Main", function(content)
    local ReachSection = createSection(content, "Reach Controls")
    local r6ToggleButton, r6ToggleStateLabel
    local r6SliderBar, r6SliderFill, r6SliderHandle, r6SliderLabel

    r6ToggleButton, r6ToggleStateLabel = createToggle(ReachSection, "R6 Reach", function(state)
        legreach = state
        if state then task.spawn(checkLegs) end
    end)
    r6SliderBar, r6SliderFill, r6SliderHandle, r6SliderLabel = createSlider(ReachSection, "Leg Distance", 1, 30, LegdistanceThreshold, function(value)
        LegdistanceThreshold = value
    end)
    createToggle(ReachSection, "R15 Reach", function(state)
        if state then
            if not RunSteppedMobile then
                RunSteppedMobile = game:GetService("RunService").RenderStepped:Connect(function()
                    local character = Player.Character
                    if not character then
                        character = Player.CharacterAdded:Wait()
                    end
                    local maxAttempts = 10
                    local attempts = 0
                    local rootPart, humanoid
                    while attempts < maxAttempts do
                        rootPart = character:FindFirstChild("HumanoidRootPart")
                        humanoid = character:FindFirstChild("Humanoid")
                        if rootPart and humanoid then
                            break
                        end
                        attempts = attempts + 1
                        task.wait(0.5)
                    end
                    if not (rootPart and humanoid) then
                        return
                    end
                    local tps = workspace:FindFirstChild("TPSSystem") and workspace.TPSSystem:FindFirstChild("TPS")
                    if rootPart and humanoid and humanoid.RigType == Enum.HumanoidRigType.R15 and tps then
                        local distance = (rootPart.Position - tps.Position).Magnitude
                        if distance <= DistanceReachMobile then
                            local preferredFoot = game.Lighting:FindFirstChild(Player.Name) and game.Lighting[Player.Name].PreferredFoot and game.Lighting[Player.Name].PreferredFoot.Value or 1
                            local targetPart = (preferredFoot == 1) and character:FindFirstChild("RightLowerLeg") or character:FindFirstChild("LeftLowerLeg")
                            if targetPart then
                                firetouchinterest(targetPart, tps, 0)
                                firetouchinterest(targetPart, tps, 1)
                            end
                        end
                    end
                end)
            end
        else
            if RunSteppedMobile then
                RunSteppedMobile:Disconnect()
                RunSteppedMobile = nil
            end
        end
    end)
    createSlider(ReachSection, "R15 Reach Distance", 1, 30, DistanceReachMobile, function(value)
        DistanceReachMobile = value
    end)
end)

createTab("Custom", function(content)
    local AdvancedReachSection = createSection(content, "Custom Reach Controls")
    createToggle(AdvancedReachSection, "Toggle Reach", function(state)
        allReachEnabled = state
        if state then
            task.spawn(checkAdvancedReach)
            if showHitbox and Player.Character then
                createHitbox(Player.Character)
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    end)
    createToggle(AdvancedReachSection, "Show Hitbox", function(state)
        showHitbox = state
        if state and allReachEnabled and Player.Character then
            createHitbox(Player.Character)
        elseif hitboxPart then
            hitboxPart:Destroy()
            hitboxPart = nil
        end
    end)
    createSlider(AdvancedReachSection, "X Reach Distance", 1, 30, XReachThreshold, function(value)
        XReachThreshold = value
        if hitboxPart and allReachEnabled and showHitbox then
            hitboxPart.Size = Vector3.new(XReachThreshold * 2, YReachThreshold * 2, ZReachThreshold * 2)
            local boxHandle = hitboxPart:FindFirstChildOfClass("BoxHandleAdornment")
            if boxHandle then
                boxHandle.Size = hitboxPart.Size
            end
        end
    end)
    createSlider(AdvancedReachSection, "Y Reach Distance", 1, 30, YReachThreshold, function(value)
        YReachThreshold = value
        if hitboxPart and allReachEnabled and showHitbox then
            hitboxPart.Size = Vector3.new(XReachThreshold * 2, YReachThreshold * 2, ZReachThreshold * 2)
            local boxHandle = hitboxPart:FindFirstChildOfClass("BoxHandleAdornment")
            if boxHandle then
                boxHandle.Size = hitboxPart.Size
            end
        end
    end)
    createSlider(AdvancedReachSection, "Z Reach Distance", 1, 30, ZReachThreshold, function(value)
        ZReachThreshold = value
        if hitboxPart and allReachEnabled and showHitbox then
            hitboxPart.Size = Vector3.new(XReachThreshold * 2, YReachThreshold * 2, ZReachThreshold * 2)
            local boxHandle = hitboxPart:FindFirstChildOfClass("BoxHandleAdornment")
            if boxHandle then
                boxHandle.Size = hitboxPart.Size
            end
        end
    end)
end)

createTab("Special", function(content)
    local SpecialSection = createSection(content, "Special Features")
    createToggle(SpecialSection, "Ball Collision", function(state)
        ballCollision = state
        local char = Player.Character
        if char and ball then
            if state then
                local constraints = {
                    ball:FindFirstChild("NoCollisionConstraintA"),
                    ball:FindFirstChild("NoCollisionConstraintB"),
                    ball:FindFirstChild("NoCollisionConstraintC")
                }
                for _, constraint in pairs(constraints) do
                    if constraint and constraint:IsA("NoCollisionConstraint") then
                        constraint.Enabled = true
                    end
                end
            else
                local constraints = {
                    ball:FindFirstChild("NoCollisionConstraintA"),
                    ball:FindFirstChild("NoCollisionConstraintB"),
                    ball:FindFirstChild("NoCollisionConstraintC")
                }
                for _, constraint in pairs(constraints) do
                    if constraint and constraint:IsA("NoCollisionConstraint") then
                        constraint.Enabled = false
                    end
                end
            end
        end
    end)
    createTextbox(SpecialSection, "Change Level (Visual)", function(value)
        local level = tonumber(value)
        if level then
            task.wait(0.1)
            local playerGui = Player:FindFirstChild("PlayerGui")
            if not playerGui then return end
            local startGui = playerGui:FindFirstChild("Start")
            if not startGui then return end
            local scores = startGui:FindFirstChild("Scores")
            if not scores then return end
            local levelLabel = scores:FindFirstChild("Level")
            if levelLabel and levelLabel:IsA("TextLabel") then
                levelLabel.Text = "Level " .. level
            end
        end
    end)
    createTextbox(SpecialSection, "Enter XP Value", function(value)
        local Targetz = tonumber(value)
        if Targetz then
            task.wait(0.1)
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            local old_index = mt.__index
            mt.__index = function(a, b)
                if tostring(a) == "XP" then
                    if tostring(b) == "Value" then
                        return Targetz
                    end
                end
                return old_index(a, b)
            end
        end
    end)
    local predictionEnabled = false
    local predictionSegments = {}
    local predictionMarker = nil
    local groundCircle = nil
    local PREDICTION_TIME = 2
    local GRAVITY = Vector3.new(0, -workspace.Gravity, 0)
    local UPDATE_INTERVAL = 0.05
    local SEGMENT_COUNT = 20
    local groundCache = {}
    local CACHE_DURATION = 0.5

    local function createPredictionVisuals()
        for _, segment in pairs(predictionSegments) do
            segment:Destroy()
        end
        predictionSegments = {}
        if predictionMarker then
            predictionMarker:Destroy()
        end
        if groundCircle then
            groundCircle:Destroy()
        end

        for i = 1, SEGMENT_COUNT do
            local segment = Instance.new("Part")
            segment.Anchored = true
            segment.CanCollide = false
            segment.Transparency = 0.5
            segment.Color = Color3.fromRGB(0, 140, 255)
            segment.Material = Enum.Material.Neon
            segment.Size = Vector3.new(0.1, 0.1, 0.2)
            segment.Parent = workspace
            table.insert(predictionSegments, segment)
        end

        predictionMarker = Instance.new("Part")
        predictionMarker.Size = Vector3.new(1, 0.2, 1)
        predictionMarker.Anchored = true
        predictionMarker.CanCollide = false
        predictionMarker.Transparency = 0.5
        predictionMarker.Color = Color3.fromRGB(0, 140, 255)
        predictionMarker.Material = Enum.Material.Neon
        predictionMarker.Parent = workspace

        local markerAdornment = Instance.new("CylinderHandleAdornment")
        markerAdornment.Height = 0.2
        markerAdornment.Radius = 0.5
        markerAdornment.Color3 = Color3.fromRGB(0, 140, 255)
        markerAdornment.Transparency = 0.5
        markerAdornment.Adornee = predictionMarker
        markerAdornment.Parent = predictionMarker

        groundCircle = Instance.new("Part")
        groundCircle.Size = Vector3.new(2, 0.1, 2)
        groundCircle.Anchored = true
        groundCircle.CanCollide = false
        groundCircle.Transparency = 0.5
        groundCircle.Color = Color3.fromRGB(0, 140, 255)
        groundCircle.Material = Enum.Material.Neon
        groundCircle.Parent = workspace

        local groundAdornment = Instance.new("CylinderHandleAdornment")
        groundAdornment.Height = 0.1
        groundAdornment.Radius = 1
        groundAdornment.Color3 = Color3.fromRGB(0, 140, 255)
        groundAdornment.Transparency = 0.5
        groundAdornment.Adornee = groundCircle
        groundAdornment.Parent = groundCircle
    end

    local function calculateTrajectory(ball)
        if not ball then return end
        local position = ball.Position
        local velocity = ball.Velocity
        local points = {}
        
        for t = 0, PREDICTION_TIME, UPDATE_INTERVAL do
            local newPos = position + velocity * t + 0.5 * GRAVITY * t * t
            table.insert(points, newPos)
        end

        return points
    end

    local function getGroundPosition(x, z)
        local cacheKey = string.format("%.2f,%.2f", x, z)
        local currentTime = tick()
        
        if groundCache[cacheKey] and (currentTime - groundCache[cacheKey].time) < CACHE_DURATION then
            return groundCache[cacheKey].y
        end

        local rayOrigin = Vector3.new(x, 1000, z)
        local rayDirection = Vector3.new(0, -2000, 0)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {game.Players.LocalPlayer.Character, ball}
        raycastParams.IgnoreWater = true
        
        local result = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        local groundY = result and result.Position.Y or 0
        
        groundCache[cacheKey] = {y = groundY, time = currentTime}
        
        return groundY
    end

    local function updatePrediction()
        while predictionEnabled do
            if ball then
                local points = calculateTrajectory(ball)
                if #points > 1 then
                    local segmentPoints = math.min(#points, SEGMENT_COUNT)
                    for i = 1, segmentPoints - 1 do
                        local segment = predictionSegments[i]
                        if segment then
                            local startPoint = points[math.floor(i * (#points / SEGMENT_COUNT))]
                            local endPoint = points[math.floor((i + 1) * (#points / SEGMENT_COUNT))]
                            if startPoint and endPoint then
                                local distance = (endPoint - startPoint).Magnitude
                                segment.Size = Vector3.new(0.1, 0.1, distance)
                                segment.CFrame = CFrame.new((startPoint + endPoint) / 2, endPoint)
                                segment.Transparency = 0.5
                            end
                        end
                    end
                    for i = segmentPoints, #predictionSegments do
                        if predictionSegments[i] then
                            predictionSegments[i].Transparency = 1
                        end
                    end

                    predictionMarker.Position = points[#points]
                    local landingPoint = points[#points]
                    local groundY = getGroundPosition(landingPoint.X, landingPoint.Z)
                    groundCircle.Position = Vector3.new(landingPoint.X, groundY + 0.05, landingPoint.Z)
                end
            end
            task.wait(UPDATE_INTERVAL)
        end
    end

    createToggle(SpecialSection, "Enable Ball Prediction", function(state)
        predictionEnabled = state
        if state then
            createPredictionVisuals()
            task.spawn(updatePrediction)
        else
            for _, segment in pairs(predictionSegments) do
                segment:Destroy()
            end
            predictionSegments = {}
            if predictionMarker then
                predictionMarker:Destroy()
                predictionMarker = nil
            end
            if groundCircle then
                groundCircle:Destroy()
                groundCircle = nil
            end
        end
    end)
    createSlider(SpecialSection, "Prediction Time", 1, 5, PREDICTION_TIME, function(value)
        PREDICTION_TIME = value
    end)
end)

createTab("React", function(content)
    local ComingSoonSection = createSection(content, "React Features")
    createLabel(ComingSoonSection, "Coming Soon...")
end)

createTab("Configs", function(content)
    local ConfigSection = createSection(content, "Reach Configurations", UDim.new(0, isMobile and 30 or 50))
    local r6SliderBar, r6SliderFill, r6SliderHandle, r6SliderLabel
    for _, tab in pairs(tabs) do
        if tab.originalName == "Main" then
            local scrollingFrame = tab.content:FindFirstChildOfClass("ScrollingFrame")
            if scrollingFrame then
                local reachSection = scrollingFrame:FindFirstChildOfClass("Frame")
                if reachSection then
                    local sliderFrame = reachSection:FindFirstChildOfClass("Frame", true)
                    if sliderFrame then
                        r6SliderBar = sliderFrame:FindFirstChildOfClass("Frame")
                        r6SliderFill = r6SliderBar and r6SliderBar:FindFirstChild("SliderFill")
                        r6SliderHandle = r6SliderBar and r6SliderBar:FindFirstChild("SliderHandle")
                        r6SliderLabel = sliderFrame:FindFirstChildOfClass("TextLabel")
                    end
                end
            end
            break
        end
    end
    
    local function updateSlider(value)
        if r6SliderBar and r6SliderFill and r6SliderHandle and r6SliderLabel then
            local min = 1
            local max = 30
            local relPos = (value - min) / (max - min)
            r6SliderFill.Size = UDim2.new(relPos, 0, 1, 0)
            r6SliderHandle.Position = UDim2.new(relPos, isMobile and -4 or -8, 0, isMobile and -3 or -5)
            r6SliderLabel.Text = "Leg Distance: " .. string.format("%.1f", value)
            LegdistanceThreshold = value
        end
    end
    
    createButton(ConfigSection, "Legit", function()
        if not legreach then
            createNotification("R6 Reach must be enabled first!", 0, "failure")
            return
        end
        LegdistanceThreshold = 5
        updateSlider(5)
        createNotification("Set R6 Reach to Legit (5)", 0, "success")
    end)
    
    createButton(ConfigSection, "Semi Legit", function()
        if not legreach then
            createNotification("R6 Reach must be enabled first!", 0, "failure")
            return
        end
        LegdistanceThreshold = 8
        updateSlider(8)
        createNotification("Set R6 Reach to Semi Legit (8)", 0, "success")
    end)
    
    createButton(ConfigSection, "Rage", function()
        if not legreach then
            createNotification("R6 Reach must be enabled first!", 0, "failure")
            return
        end
        LegdistanceThreshold = 30
        updateSlider(30)
        createNotification("Set R6 Reach to Rage (30)", 0, "success")
    end)
end)

createTab("Settings", function(content)
    local PlaceholderSection = createSection(content, "Settings")
    
    local spacer = Instance.new("Frame")
    spacer.Size = UDim2.new(1, 0, 0, isMobile and 10 or 20)
    spacer.BackgroundTransparency = 1
    spacer.Parent = PlaceholderSection

    local hotkey = Enum.KeyCode.RightControl
    local isChangingKey = false

    local hotkeyButton = createButton(PlaceholderSection, "Change Hotkey", function()
        if isChangingKey then return end
        isChangingKey = true
        hotkeyButton.Text = "Press a key..."
    end)

    UIS.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if isChangingKey and input.UserInputType == Enum.UserInputType.Keyboard then
            hotkey = input.KeyCode
            hotkeyButton.Text = "Hotkey: " .. hotkey.Name
            isChangingKey = false
        elseif input.KeyCode == hotkey then
            if KyroGui then
                KyroGui.Enabled = not KyroGui.Enabled
            end
        end
    end)
end)

tabs[1].button.MouseButton1Click()
